--- 1. Основна идея:
Идеята е много проста. Знаем, че в конфигурационния файл ще имаме сегменти, като всеки сегмент е съставен от 64 бита. Също знаем, че имаме 3 типа сегменти - текстов, цифров и еднобайтов.
За целта си създаваме 3 основни структури за всеки тип сегмент.

За нашето конктретно устройство, за което правим инструмент, който да конфигурира данните му, знаем, че конфигурационният му файл се състои от 5 сегмента, както следва в следния ред:
- 0 текстов, 1 текстов, 2 цифров, 3 еднобайтов, 4 текстов.

И си създаваме 5 сегмента, всеки според вида си. И след това, когато ни дадът конфигурационния файл, то ния директно си му даваме дадената структура и то си я пълни.

--- 2. Алгоритъм:

В main() частта, правим проверка, какво желае потребителя. Ако той иска да види help информация, т.е. ако е подал "-h", то му показваме примери за това как се използва програмата.

При всички останали случаи и аргументи, които подава потребителя, се действа по различен начин.

За начало отваряме конфигурационният файл, който всъщност се намира на позиция 1 в масива argv, тоест отваряме файла argv[1]

След като сме отворили файла, извикваме функция, която прави extract-ване на всички сегменти от дадения файл. Така си запазваме всички сегменти в структури, за по-лесна манипулация и затваряме файла.

Вече имаме всички сегменти и тяхната информация запазени в нашите структури отговарящи за сегментите.

Създадени са множество помощни функции, които да ни вършат определена работа. Тъй като са много функции, ще дам пример само с част от тях:
- text_segment_options_validator -> ф-ция, която валидира стойностите за даден параметър
- extract_all_segments -> по даден fd, изважда от файла всички сегменти и ги запазва в структури
- set_meta_bits -> Прави определен бит Активен в мета информацията
- get_meta_bit_by_position -> Връща дали е Активен или Не определен бит в мета информацията
- change_param_value_of_text_segment -> Променя стойността на даден параметър
- show_param_value_by_param_name -> Показва стойността на даден параметър
- show_all_params -> Показва всички налични параметри
- export_data -> Запазва всички сегменти в даден файл. Като в нашия случай, ние използваме тази функция, като и подаваме същия файл от който сме чели. Тоест след като променим информацията си я запазваме отново като подаваме на тази функция името на конфигурационния файл, който се съхранява в argv[1]
- ... и много други функции, които улесняват работата

И така, вече след като си имаме помощни функции, чрез които манипулирането и преглеждането на информация от сегментите ще е значително по-лесно, то вече може да предоставим необходимата функционалност, която се изисква, чрез проверка на аргументите, и най-често проверка на 2-рия аргумент, т.е. argv[2], дали е "-s", "-l", и т.н.

И взависимост от това, каква опция трябва да изпълни програмата, то се извикват съответните помощни функции, така че да бъдат удовлетворени изискванията за съответната функционалност.

Това е като цяло. Идеята е доста проста, но много ефективна.

--- 3. Източници:

- https://www.scadacore.com/tools/programming-calculators/online-hex-converter/ - Използвах този сайт за да правя изчисления и разшифроване в началото на процеса на решаване на задачата. Използвах го за да тествам неща свързани с дадените примери.

- https://www.quora.com/How-do-I-use-regular-expressions-in-the-C-programming-language - От тук взех функция, която ми прави проверка и валидация за регулярни изрази, като и подам стринг и регулярен израз, тя връща дали е валиден стринга.