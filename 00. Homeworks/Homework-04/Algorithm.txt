--- 1. Основна идея:
Идеята е много проста. Използваме споделена памет и семафори за да синхронизираме сървъра и клиентите.

Имаме 4 семафора - 2 за да контролират синхронизацията между сървъра и отделните клиенти (sem_server и sem_client) и 2, които синхронизират заявките между един клиент и сървъра (sem_t1 и sem_t2).

Имаме 1 структура (Memory), която стои в споделената памет.

Като във файла comm.h са изнесени всички общи неща и за двата файла (server.c и client.c)

--- 2. Алгоритъм:

Когато се стартира сървъра, първо се прави проверка дали подадения файл в който се съхраняват сметките съществува. Ако не съществува, то се създава нов празен файл и в него всички сметки са с баланс 0.

След това създаваме signal handler, който когато сървъра е спрян, дали чрез SIGTERM или SIGINT то се записва в log файл информация за спирането на сървъра.

После си създаваме споделената памет и си пълним структурата, която стои в споделената памет.
И си инициализираме 4-те семафора, които ще са ни нужни. Като семафора sem_client го инициализираме с първоначален брояч 1, за да може първият клиент да си се пусне.

Пускаме 1 безкраен цикъл, който ще си се върти и ще обработва клиентите и заявките им.

В тялото на цикъла ще се влезе, когато семафора sem_server получи сигнал, това се случва, когато клиент се свърже към сървъра.

Правим проверка дали account id е валидно и ако е валидно връщаме какъв е баланса на подадената ни сметка. Ако не е валидно, то задаваме статус 2, което значи, че account id е невалидно и след това клиента вижда, че е зададен такъв статус 2 и прекратява изпълнението си.

Клиента въвежда сума, която ще тегли или внася и изпраща заявка към сървъра, ако въведената сума е сума за теглене и тя е по-голяма от наличния баланс, то сървъра задава статус 3, което означава, че въведената сума е невалидна, клиента вижда, че статуса е вече 3 и спира изпълнението си.

Ако няма проблеми със дадената сума за теглене или внасяне, то сървъра записва промените във файла и задава статус 4, което означава, че всичко е преминало успешно.

Като цялото това нещо с изчакването на заявка и връщането на резултат се случва с 2-та семафора sem_t1 и sem_t2.

Накрая даваме сигнал и увеличаваме брояча на семафора sem_client, с което позволяваме на следващия клиент да получи достъп до сървъра.

Това е като цяло. Идеята е доста проста, но много ефективна.

Може да имаме много едновременни клиенти, като семафора ще се погрижи, сървъра да ги обработва 1 по 1 и всичко да е точно.

--- 3. Източници:

- Използвах множество източници за да разбера как работи споделената памет и семафорите и гледах различни примери и уроци.

-- Споделена памет:
- https://www.geeksforgeeks.org/ipc-shared-memory/
- https://www.youtube.com/watch?v=SMeDw2GDMsE

-- Semaphores и Shared Memory - урок как се реализират семафори и споделена памет
- https://www.youtube.com/watch?v=Om2t1xgEUQE
- http://cgi.di.uoa.gr/~ad/k22/k22-lab-notes4.pdf
- https://stackoverflow.com/questions/49704593/shared-memory-sync-using-semaphore

-- Signal Handling - тук видях как се прави signal handling за спирането на сървъра
- https://www.geeksforgeeks.org/signals-c-language/

-- Date and Time 
- https://stackoverflow.com/questions/1442116/how-to-get-the-date-and-time-values-in-a-c-program

-- Check file exist
- https://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c
